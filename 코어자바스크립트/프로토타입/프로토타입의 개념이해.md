#### 그림 6-2의 윗변의 왼쪽 꼭짓점에는 constructor를 , 오른쪽 꼭짓점에는 constructor.prototype이라는 프로퍼티를 위치시켰습니다. 왼쪽 꼭짓점으로부터 아래를 향한 화살표 중간에 new가 있고, 화살표 종점에는 Instance가 있습니다. 오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 instance.__proto__이라는 프로퍼티를 위치시켰습니다. 코드 6-1과 그림 6-2를 번갈아 보면서 흐름을 따라가 봅시다. 

* 어떤 생성자 함수를 new 연산자와 함께 호출하면 
* constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성됩니다. 
* 이때 instance에는 __proto__라는 프로퍼티가 자동으로 부여되는데, 
* 이 프로퍼티는 constructor의 prototype이라는 프로퍼티를 참조합니다. 

#### prototype이라는 프로퍼티와 __proto__ 라는 프로퍼티가 새로 등장했는데, 이 둘의 관계가 프로토타입 개념의 핵심입니다. prototype은 객체입니다. 이를 참조하는 __proto__ 역시 당연히 객체겠죠. prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장합니다. 그러면 인스턴스에서도 숨겨진 프로퍼티인 __proto__를 통해 이 메서드들에 접근할 수 있게 됩니다. 

#### 예를 들어, Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 저장했다고 해보죠. 

<pre>
<code>
var Person = function(name){
    this._name = name;
}

Person.prototype.getName = function(){
    return this._name;
}
</pre>
</code>

#### 이제 이 Person의 인스턴스는 __proto__ 프로퍼티를 통해 getName을 호출할 수 있습니다. 

<pre>
<code>
var suzi = new Person('Suzi');
suzi.__proto__.getName(); // undefined
</pre>
</code>

##### 왜냐하면 instance의 __proto__가 constructor의 prototype 프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 떄문이죠. 

<pre>
<code>
Person.prototype === suzi.__proto__ //true
</pre>
</code>

##### 메서드 호출 결과로 undefined가 나온 점에 주목해 봅시다. 'Suzi'라는 값이 나오지 않은 것보다는 '에러가 발생하지 않았다'는 점이 우선입니다. 어떤 변수를 실행해 undefined가 나왔다는 것은 이 변수가 '호출할 수 있는 함수'에 해당한다는 것을 의미합니다. 만약 실행할 수 없는, 즉 함수가 아닌 다른 데이터 타입이었다면 typeError가 발생했을 것입니다. 그런데 값이 에러가 아닌 다른 값이 나왔으니까 getName이 실제로 실행되었음을 알 수 있고, 이로부터 getName이 함수라는 것이 입증되었습니다. 

##### 다음으로 함수 내부에서 어떤 값을 반환하는지 살펴볼 차례입니다. this.name 값을 리턴하는 내용으로 구성돼있네요. 그렇다면 this에 원래의 의도와는 다른 값이 할당된 것이 아닐까, 라는 의심을 가져볼 수 있겠습니다. 이런 의심을 가지고 로그를 출력해 보거나 debugger를 지정하는 등으로 의심되는 사항을 하나하나 추적하다 보면 원인을 파악할 수 있겠죠. 다행히 우린 이미 상황별로 어떤 값이 this에 할당되는지 살펴본 바 있습니다. 이 지식을 바탕으로 디버깅 과정을 거치지 않고도 문제를 파악할 수 있겠습니다. 결론부터 말씀드리면, 문제는 바로 this에 바인딩된 대상이 잘못 지정됐다는 것입니다. 
##### 어떤 함수를 '메서드로서' 호출할 때는 메서드명 바로 앞의 객체가 곧 this가 된다고 했습니다. 그러니까 thomas.__proto__.getName()에서 getName() 함수 내부에서의 this는 thomas가 아니라 thomas.__proto__라는 객체가 되는 것입니다. 이 객체 내부에는 name프로퍼티가 없으므로 '찾고자 하는 식별자가 정의돼 있지 않을 때는 Error 대신 undefined를 반환한다'라는 자바스크립트 규약에 의해 undefined가 반환된 것입니다. 

##### 그럼 만약 __proto__ 객체에 name 프로퍼티가 있다면 어떨까요? 

<pre>
<code>
var suzi = new Person('Suzi');
suzi.__proto__._name = 'SUZI__proto__';
suzi.__proto__.getName(); //SUZI_proto__
</pre>
</code>

##### 예상대로 SUZI_proto__가 잘 출력됩니다. 그러니까 관건은 this입니다.this를 인스턴스로 할 수 있다면 좋겠습니다. 그 방법은 __proto__ 없이 인스턴스에서 곧바로 메서드를 쓰는 것입니다. 

<pre>
<code>
var suzi = new Person('Suzi', 28);
suzi.getName() //Suzi
var iu = new Person('Jieun', 28);
iu.getName() //Jieun
</pre>
</code>

##### 