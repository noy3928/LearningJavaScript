##### 프로토타입 체인을 설명하기에 앞서 이번에는 객체의 내부 구조를 살펴봅시다. 

<pre>
<code>
console.dir({a:1})
</code>
</pre>

##### 첫 줄을 통해 Object의 인스턴스임을 알 수 있고, 프로퍼티 a의 값 1이 보이고, __proto__ 내부에는 hasOwnProperty, isPrototypeOf, toLocaleString, toString 등의 메서드가 보입니다. hasOwnProperty, toString 등은 친숙하네요. contructor는 생성자 함수인 Object를 가리키고 있습니다. 

##### 이번에는 다시 한 번 배열의 구조를 살펴봅시다. __proto__ 내부의 다양한 메서드들을 생략하고 나머지 부분 위주로 표기했습니다. 

##### 배열 리터럴의 __proto__에는 pop, push 등의 익숙한 배열 메서드 및 constructor가 있다는 것은 6-1-1절에서 이미 말씀드렸습니다.추가로, 이 __proto__ 안에는 또다시 __proto__가 등장합니다. 열어보니 그림 6-7에서 살펴본 객체의 __proto__와 동일한 내용으로 이뤄져 있습니다. 왜 그럴까요? 바로 prototype객체가 '객체'이기 때문입니다. 기본적으로 모든 객체의 __proto__에는 Object.prototype이 연결됩니다. prototype객체도 예외가 아닙니다. 이를 그림으로 표현하면 다음과 같습니다. 

##### __proto__는 생략 가능하다고 했습니다. 그렇기 때문에 배열이 Array.prototype 내부의 메서드를 마치 자신의 것처럼 실행할 수 있었죠 마찬가지로 Object.prototype 내부의 메서드도 자신의 것처럼 실행할 수 있습니다. 생략 가능한 __proto__ 를 한 번 더 따라가면 Object.prototype을 참조할 수 있기 때문이죠. 

<pre>
<code>
var arr = [1,2];
arr(.__proto__).push(3);
arr(.__proto__)(.__proto__).hasOwnProperty(2); //true
</code>
</pre>

##### 어떤 데이터의 __proto__ 프로퍼티 내부에 다시 __proto__ 프로퍼티가 연쇄적으로 이어진 것을 프로토타입 체인이라고 하고, 이 체인을 따라가며 검색하는 것을 프로토타입 체이닝이라고 합니다. 

##### 프로토타입 체이닝은 6-2절에서 소개한 메서드 오버라이드와 동일한 맥락입니다. 어떤 메서드를 호출하면 자바스크립트 엔진은 데이터 자신의 프로퍼티들을 검색해서 원하는 메서드가 있으면 그 메서드를 실행하고, 없으면 __proto__를 검색해서 있으면 그 메서드를 실행하고, 없으면 다시 __proto__를 검색해서 실행하는 식으로 진행합니다. 

<pre>
<code>
var arr = [1,2];
Array.prototype.toString.call(arr); // 1,2 
Object.prototype.toString.call(arr); // [object Array]
arr.toString();

arr.toString = function(){
    return this.join('_');
}
arr.toString(); //1_2
</code>
</pre>