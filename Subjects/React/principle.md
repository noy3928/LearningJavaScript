# 리액트의 디자인 원칙

## 스케줄링 :

작성된 컴포넌트들이 함수로 작성되었을지라도, 리액트를 사용할 때 그것을 직접적으로 호출하지 않는다.  
모든 컴포넌트들은 무엇이 렌더링되어야할지에 대한 desc를 반환한다. 그리고 그 desc는 아마도 유저가 작성한 <LikeButton>이나 <div>같은 컴포넌트들을 포함하고 있을 것이다. 이제 LikeButton 같은 컴포넌트를 해석하는 것이나 컴포넌트의 렌더링 결과물을 실제 UI tree에 적용하는 그 미래의 시점은 리액트에게 달려있다.

이것은 미세한 차이이지만, 굉장히 강력한 것이다.  
당신이 컴포넌트 함수를 호출하는 것이 아니라, 리액트가 그것을 호출하는 것이기 때문에,  
이것은 리액트가 필요하면 호출을 미룰 권한을 가진다는 의미가 된다.
현재의 구현에서는 React는 트리를 재귀적으로 조사하고 단일 Tick 동안에 전체 갱신된 트리의 렌더링 함수를 호출한다.  
하지만 미래에는 dropping frame을 피하기 위해서, update를 미루도록 할 것이다.

이것이 리액트 디자인의 일반적인 테마다.  
몇몇 인기 있는 라이브러리는 push 접근 방법을 취한다.
이 접근법은 데이터가 가능하기만 하면 계산이 수행되는 방식이다.  
그런데, 리액트는 pull 접근 방법을 고수한다.  
이 접근법은 필요할 때까지 미루는 방식이다.

리액트는 일반적인 데이터흐름 라이브러리와는 다르다.  
이것은 ui를 만들기 위한 라이브러리다.  
우리 리액트팀은 리액트가 특별한 위치를 점유했다고 생각합니다.  
그 지점이란 어떤 계산이 현재 필요하고 필요하지 않은지에 대한 것입니다.

만약 무언가가 화면 바깥에 있다면, 우리는 그것과 관련된 어떤 로직이든 미룰 수 있다.  
만약에 데이터가 frame 비율보다 더 일찍 도착한다면, 우리는 한꺼번에 모아서 처리하도록 만들 수 있습니다.  
우리는 유저 인터렉션으로부터 나온 작업에 더 우선순위를 가지도록 만들 수 있고,  
프레임 드롭을 피하기 위해서 백그라운드 작업(네트워크로부터 받아온 페이지를 렌더링한다던지)을 후순위로 처리할 수도 있습니다.

명확하게 이야기하자면, 우리는 아직 이 이점을 적용하고 있지는 않습니다.  
하지만 이런 작업들을 할 수 있다는 자유는 왜 우리가 스케줄링에 대한 컨트롤을 가지는 것을 선호하는지에 대한 이유가 됩니다.  
그리고 왜 setState가 비동기인지두요.  
개념적으로 말해보자면, 우리는 이것을 'scheduling an update'라고 생각합니다.

만약 Functional Reactive Programming 의 한 방식인 push 기반 페러다임을 사용했더라면,  
이런 스케줄링에 대한 통제력을 가지는 것이 쉽지 않았을 것입니다. 우리는 'glue'코드를 가지고 싶습니다. (딱 맞는 코드를 가지고 싶습니다? )

리액트로 돌아가기 전에 수행되는 유저의 많은 코드를 최소화하는 것이 리액트의 핵심목표입니다.
이것은 React가 UI에 대해서 알고 있는 지에 따라 작업을 스케쥴하고 청크로 분할하는 능력을 유지한다는 것을 보증합니다.

[참고자료 : https://reactjs.org/docs/design-principles.html]
