#### 그림 6-2의 윗변의 왼쪽 꼭짓점에는 constructor를 , 오른쪽 꼭짓점에는 constructor.prototype이라는 프로퍼티를 위치시켰습니다. 왼쪽 꼭짓점으로부터 아래를 향한 화살표 중간에 new가 있고, 화살표 종점에는 Instance가 있습니다. 오른쪽 꼭짓점으로부터 대각선 아래로 향하는 화살표의 종점에는 instance.__proto__이라는 프로퍼티를 위치시켰습니다. 코드 6-1과 그림 6-2를 번갈아 보면서 흐름을 따라가 봅시다. 

* 어떤 생성자 함수를 new 연산자와 함께 호출하면 
* constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성됩니다. 
* 이때 instance에는 __proto__라는 프로퍼티가 자동으로 부여되는데, 
* 이 프로퍼티는 constructor의 prototype이라는 프로퍼티를 참조합니다. 

#### prototype이라는 프로퍼티와 __proto__ 라는 프로퍼티가 새로 등장했는데, 이 둘의 관계가 프로토타입 개념의 핵심입니다. prototype은 객체입니다. 이를 참조하는 __proto__ 역시 당연히 객체겠죠. prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장합니다. 그러면 인스턴스에서도 숨겨진 프로퍼티인 __proto__를 통해 이 메서드들에 접근할 수 있게 됩니다. 

#### 예를 들어, Person이라는 생성자 함수의 prototype에 getName이라는 메서드를 저장했다고 해보죠. 

<pre>
<code>
var Person = function(name){
    this._name = name;
}

Person.prototype.getName = function(){
    return this._name;
}
</pre>
</code>

#### 이제 이 Person의 인스턴스는 __proto__ 프로퍼티를 통해 getName을 호출할 수 있습니다. 

<pre>
<code>
var suzi = new Person('Suzi');
suzi.__proto__.getName(); // undefined
</pre>
</code>

#### 왜냐하면 instance의 __proto__가 constructor의 prototype 프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라보기 떄문이죠. 

<pre>
<code>
Person.prototype === suzi.__proto__ //true
</pre>
</code>

#### 메서드 호출 결과로 undefined가 나온 점에 주목해 봅시다. 'Suzi'라는 값이 나오지 않은 것보다는 '에러가 발생하지 않았다'는 점이 우선입니다. 어떤 변수를 실행해 undefined가 나왔다는 것은 이 변수가 '호출할 수 있는 함수'에 해당한다는 것을 의미합니다. 만약 실행할 수 없는, 즉 함수가 아닌 다른 데이터 타입이었다면 typeError가 발생했을 것입니다. 그런데 값이 에러가 아닌 다른 값이 나왔으니까 getName이 실제로 실행되었음을 알 수 있고, 이로부터 getName이 함수라는 것이 입증되었습니다. 


