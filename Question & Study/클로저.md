# 똑같은 scope인데, inner 함수에서 a만 참조하고, b는 참조하지 않는다면 b는 청소될까?

내가 생각하는 예시 상황은 다음과 같다.

<pre>
<code>
function outer(){
    let a = 0;
    let b = 0;
    function inner(){
        return a ++;
    }
    return inner
}
</code>
</pre>

여기서 a는 inner가 사용한다. 때문에 a의 참조카운트는 0이 아니므로 가비지 컬렉팅되지 않는다.  
그런데 b는 참조카운트가 0이다.  
그렇다면 b는 청소될 것이라고 판단하는 것이 맞을 것 같은데,  
궁금한 부분은 다음과 같은 문장 때문이다.

> outerEnvironmentReference에는 Inner 함수가 선언된 위치의 lexicalEnvironment가 참조복사됩니다.

그러니까 lexicalEnvironment가 복사되는 것이라면, 그 내용에는 b도 포함되는 것이 아닌가???
b는 청소되는가 청소되지 않는가????

<br>

이에 대해서 mdn에서는 또 이렇게 말하고 있다.

> A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created.

any local variables that were in-scope at the time the closure was created

클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수

이 말에 의하면, b 또한 청소되지 않고 남아있는 것으로 이해할 수 있는것일까?  
근데 만약에 함수안에 무수히 많은 변수가 선언되어 있다고 치자면, 예를들어 만개의 변수가 선언되어있다.  
그런데, 그 중에서 딱 하나의 변수가 inner함수에서 참조되고 있다.  
그러면 그 만개의 변수 모두가 같은 지역에 있는 변수였다는 이유로 청소되지 않는 것일까??

-> 아 <함수형 자바스크립트 프로그래밍> 이라는 책에서 이런 말을 했다.

> 자신이 생성될 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 때 사용할 변수들만을 기억하여 유지시키는 함수

변수들 '중' 사용할 변수들'만'이라고 적혀있는 것을 보아하니,
a이외의 다른 변수들은 사라질 것 같은데,  
확인이 필요하다...

-> 모던 자바스크립트 딥 다이브 책에서 또 다른 대답을 얻었다.

> 모던 자바스크립트 딥 다이브 p.400-401
>
> > 이런 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프의 식별자 중에서 클로저가 참조하고 있는 식별자만을 기억한다. 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수라고 부른다. 클로저란 '함수가 자유 변수에 대해 닫혀있다'라는 의미이다. 이를 좀 더 알기 쉽게 의역하자면 '자유 변수에 묶여있는 함수'라고 할 수 있다.
> > 이론적으로 클로저는 상위 스코프를 기억해야 하므로 불필요한 메모리의 점유를 걱정할 수도 있겠다. 하지만 모던 자바스크립트 엔진은 최적화가 잘 되어 잇어서 클로저가 참조하고 있지 않는 식별자는 기억하지 않는다. 즉, 상위 스코프의 식별자 중에서 기억해야 할 식별자만 기억한다.

새롭게 알게 된 지식은 '자유 변수'. 생명주기가 끝나고도 사용할 수 있는 변수를 '자유 변수'라고 부른다.  
나만의 언어로는 '좀비 변수'라고도 부를 수 있지 않을까? 싶은 생각이 들었다.이게 조금 더 재미있고 직관적이다.  
외부의 모든 lexicalEnvironment와 거기에 있던 변수들이 죽었는데도, 본인은 살아있기 때문이다.  
'좀비변수'. 물론, 의사소통을 위해서는 자유 변수를 사용하는 것이 좋겠다.
