# 커링과 배열 메서드를 조합한 부분적용 함수를 사용하라

<br>

### 이전에 살펴봤던 내용, 그리고 아직 남아있는 한계점

이전 팁에서는 고차 함수와 부분 적용을 이용해 매개변수에 단일 책임을 부여하는 방법을 살펴봤다.  
관련이 없는 매개변수로 인한 문제는 해결했지만,  
같은 매개변수를 반복해서 사용하는 문제는 해결할 수 없었다.  
여전히 같은 매개 변수를 여러번 전달하고 있다.  
<br>

고차 함수를 사용하면 값을 한 번 저장한 후 나중에 사용할 수 있는 새로운 함수를 만들어서 반복을 피할 수 있다.   
고차 함수에서 반환된 함수는 바로 다시 호출할 필요가 있다.   
고차 함수를 한 번 호출하면 계속해서 사용할 수 있는 새로운 함수가 반환되기 때문이다.  
마치 인수를 하드 코딩해둔 함수를 작성하는 것과 같다.  
<br>

이전 팁에서 살펴봤던 건물과 행사 장소 담당자를 재사용하려면, 첫 번째 함수 호출의 반환값을 변수에 할당하면 된다.   
그 결과 일부 정보를 담고 있는 사전 제작 함수가 생성된다.  

함수를 한 번 호출해 저장해둔 매개 변수를 다시 사용하는 것은 내부 변수를 미리 알고 있는 함수를 선언하는 것과 같다.   

<pre>
<code>
const setStrongHallProgram = mergeProgramInformation(building, manager);
const programInfo = setStrongHallProgram(program);
const exhibitInfo = setStrongHallProgram(exhibit);
</code>
</pre>

<br>
<pre>
<code>
const setStrongHallProgram = program => {
    const defaults = {
        hours : '8 am - 8 pm',
        address : 'Jayhawk Blvd',
        name : 'Augusto',
        phone : '555-5555-5555'
    }
    return {...default, ...program};
}

const programs = setStrongHallProgram(program);
const exhibit = setStrongHallProgram(exhibit);
</code>
</pre>


<br>
첫 번째 함수는 고차 함수의 부분 적용을 활용해 작성했다.   
두 번째 함수는 정보를 하드 코딩했다.  
두 차례에 걸쳐 인수를 받는 고차 함수가 하드 코딩된 정보보다 유연하기는 하다.   
그렇지만 두 함수를 살펴보면 유사점을 찾을 수 있다. 

<br>
고차 함수를 이용하면 매개변수를 별도로 분리할 수 있다.   
그렇지만 함수를 완전히 분리하기 전에 함수에 필요한 인수의 수를 줄일 수 있도록   
**인수를 분리하는 것이 훨씬 더 중요하다.**      
한 번에 인수를 하나만 받는 함수를 '커링'이라고 하며, 
이는 하나의 인수만 전달하는 메서드를 다룰 때 매우 유용하다.   
자바스크립트는 순수한 형태의 커링을 완벽하게 지원하지는 않지만, 부분 적용을 이용해서 단일 매개변수 숫자를 줄이는 방법이 일반적이다. 

> 한 번에 인수를 하나만 받는 함수를 '커링'이라고 한다. 
<br>

> 커링과 부분 적용 
>> 부분 적용 함수는 매개변수를 여러 번 받을 수 있다. 그래서 종종 커링과 혼동된다.  실제로 컬링과 부분 적용 함수는 매우 비슷하지만, 이 둘은 엄격히 다르다.<br> 부분 적용함수와 커링 함수는 모두 원래보다 필요한 인수의 수가 적은 함수를 반환해 인수의 수를 줄인다.  함수에는 함수가 받을 수 있는 전체 인수의 수가 있으며 **항수**라고 부른다. 부분 적용 함수는 원래의 함수보다 항수가 적은 함수를 반환한ㄷ. 인수가 총 세 개 필요한 경우에는 인수 두 개를 먼저 전달했다면, 여기서 반환된 함수에는 인수가 하나만 있으면 된다. 원래의 함수는 세 개의 인수가 필요했다. 여기에 부분 적용 함수를 이용하면 항수가 하나인 함수를 반환한다. <br> 반면에 커링 함수는 여러 개의 인수를 받는 함수에서 정확히 인수 하나만 받는 일련의 함수를 반환할 때 사용한다. 가령 인수 세 개가 필요한 함수가 있다면, 먼저 인수 하나를 받는 고차함수가 다른 함수를 반환하고, 반환된 함수도 인수 하나를 받는다.  이 함수에서 끝으로 인수 하나를 받는 마지막 함수가 반환된다. 

## 매개변수를 줄이는 방법을 도입해보기 

<br>
강아지에 대한 정보가 담긴 배열을 필터링 했던 것을 다시 떠올려보자.   
그때는 필터 함수만 만들고 실제로는 적용하지는 않았다.  


<pre>
<code>
const dogs = [
    {
        이름 : '맥스',
        무게 : 10,
        견종 : '보스턴테리어',
        지역 : '위스콘신',
        색상 : '검정색'
    },
        {
        이름 : '도니',
        무게 : 90,
        견종 : '래브라도레트리버',
        지역 : '캔자스',
        색상 : '검정색'
    },
        {
        이름 : '섀도',
        무게 : 40,
        견종 : '래브라도레트리버',
        지역 : '위스콘신',
        색상 : '갈색'
    }
]
</code>
</pre>

강아지 배열과 필터 조건을 인수로 받은 후 필터링 조건에 맞는 강아지의 이름만 모아서 반환하는 함수를 작성해보자.   
강아지 배열을 첫 번째 매개변수로 전달하고, filter와 map을 조합해 최종 결과 집합을 얻는다. 

<pre>
<code>
function getDogNames(dogs, filter){
    const [key, value] = filter;
    return dogs
        .filter(dog => dog[key] === value)
        .map(dog => dog['이름'])
}
getDogNames(dogs, ['색상', '검정색'])
//['맥스', '도니']
</code>
</pre>

## 위 코드의 2가지 문제점 

위 코드는 나쁘지 않아보이지만, 제약이 매우 심하다. 두 가지 문제점이 있다.  
1) 필터 함수에 제약이 있다.   
필터 함수는 필터와 각각의 강아지를 정확하게 비교할 때만 정상적으로 작동한다.   
즉, === 을 사용할 때만 작동한다. 만약 무게가 일정한 수준보다 적은 강아지를 찾아야 한다면 필터 조건을 어떻게 해야할까? 

2) 모든 배열 메서드와 마찬가지로 map은 검사하는 항목만 인수로 받을 수 있기 때문에 유효 범위 내의 다른 변수들을 가져올 방법이 필요하다. 
map은 다른 함수 내부의 함수이므로 이를 감사고 있는 함수의 변수에 접근할 수 있다.  
즉, 매개변수를 이용해서 외부 함수에 필요한 변수를 전달항 방법이 필요하다.

## 2가지 문제점에 대한 해결

<br>
우선 1)문제부터 풀어보자. 정해진 체중보다 무게가 적게 나가는 강아지를 찾을 수 있는 함수를 작성해보자.  
우리는 함수에 다른 함수를 주입하는 방법을 이미 살펴봤다.  
여기서 시작해보자. 비교 함수를 하드 코딩하지 않고 필터 함수에 콜백 함수로 전달할 수 있게 만들어보자. 

<pre>
<code>
function getDogNames(dogs, filterFunc){
    return dogs
        .filter(filterFunc)
        .map(dog => dog['이름'])
}

getDogNames(dogs, dog => dog['무게'] < 20);
// ['맥스']
</code>
</pre>

### 인수의 하드코딩을 벗어버리기 
<br>
목표 달성이 머지 않았다. 그렇지만 이 경우에도 숫자 20과 같은 값을 하드 코딩하고 있다.   
즉, 변수를 사용할 때 직접 코딩해서 넣거나 유효 범위의 충돌이 없는지 확인하는 절차를 거치고 있다.  
별문제가 아닌 것처럼 보이지만, 유효범위 충돌은 우리가 가장 예상하지 못한 순간에 찾아오곤 한다.   

<br>
우리의 목표는 부분 적용 함수를 이용해서 필요한 값을 미리 담아두는 것이다.  
부분 적용 함수를 변수에 할당해서 다른 함수에 데이터로 전달하는 방법으로 나머지 인수를 제공할 수 있다.  


이렇게 되면 getDogNames() 함수를 다시 작성할 필요도 없다.  
getDogNames()는 모든 형태의 비교 함수를 받을 수 있기 때문에, 준비가 끝났다.  
이제 우리가 해야 할 일은 비교 함수를 다시 작성해서 비교를 위한 값을 매번 하드 코딩할 필요가 없도록 만드는 것 뿐이다. 


이전에 살펴본 팁에서 배운 기술을 바탕으로 인수 집합을 두 개 만든다.  
첫 번째 집합은 무게이고, 두 번째 집합은 개별 강아지의 정보이다.   

이제 무게를 하나 정해서 먼저 함수를 적용하고, 또 다른 경우에는 다른 무게를 적용할 수 있게 되었다.  
실제 비교에 사용할 기준 무게는 함수에 담긴다.  
즉, 서로 다른 무게를 기준으로 해도 계속해서 함수를 재사용할 수 있다.  
유효 범위 충돌이 발생할 가능성도 거의 없다.   

<pre>
<code>
const weightCheck = weight => dog => dog['무게'] < weigth; 

getDogNames(dogs, weightCheck(20));
//['맥스']

getDogNames(dogs, weghtChect(50));
//['맥스', '섀도']
</code>
</pre>

가장 중요한 부분은 반드시 두 개의 함수와 두 개의 인수 집합으로 제한할 필요가 없다는 점이다.  
커링을 사용해 원래의 비교 함수를 다시 작성한다면 어떻게 할 수 있을까?  

먼저 첫 번째 함수에서 색상과 같은 비교 대상을 지정한다.   
다음 함수에서 '검정색'과 같은 비교할 값을 전달한다.  

마지막 함수는 개별 강아지에 대한 정보를 받는다.  
다음 예제 코드처럼 동일한 논리를 매개변수만 달리해서 여러가지 항목으로 비교할 수 있다.  

<pre>
<code>
const identity = field => value => dog => dog[field] === value;
const colorCheck = identity('색상')
const stateCheck = identity('지역');

getDogNames(dogs, colorCheck('갈색'));
//['섀도']

getDogNames(dogs, stateCheck('캔자스'))
//['섀도']
</code>
</pre>

## 정리 

이제 우리가 무엇을 했는지 정리해보자.   
우리는 특정한 요구 사항이 있는 함수를 가져와서 여러 가지 다른 비교를 할 수 있도록 추상화를 만들었다.  
부분 적용 함수를 변수에 할당할 수 있고, 이 변수를 데이터로 전달할 수도 있었다.  
즉, 간단한 도구 모음을 사용해서 매우 정교하게 비교할 수 있다.  

예를 들어 모든 조건을 충족하는 강아지를 찾아야 한다면, 검사에 사용할 여러 개의 비교 함수를 전달하고 
배열 메서드인 every메서드를 사용할 수 있다. 이는 모든 값이 true를 반환할 때 true를 반환한다. 

최소한 하나의 조건을 충족하는 강아지를 찾는 경우에는 every 대신 다른 배열 메서드 some을 사용하자.  
some메서드는 실행 결과 중 하나라도 true를 반환하면 true를 반환한다.  

<pre>
<code>
function allFilters(dog, ...checks){
    return dogs
        .filter(dog => checks.every(check => check(dog)))
        .map(dog => dog['이름'])
}

allFilters(dogs, colorCheck('검정색'), stateCheck('캔자스'))
//['도니']

function anyFilters(dogs, ...checks){
    return dogs
        .filter(dog => checks.some(check => check(dog)))
        .map(dog => dog['이름']);
}

anyFilters(dogs, weightCheck(20), colorCheck('갈색'))
// ['맥스', '섀도']
</code>
</pre>

복잡해 보이는가?   
커링은 인수가 하나만 있어야 하는 함수를 작성할 때 훌륭한 도구라는 점만 기억해두자.  
커링은 복잡한 문제를 매우 간단하게 만들어준다.  

