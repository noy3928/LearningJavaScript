##### 자바스크립트의 기본 내장 데이터 타입들은 모두 프로토타입 체인이 1단계이거나 2단계로 끝나는 경우만 있었지만 사용자가 새롭게 만드는 경우에는 그 이상도 얼마든지 가능합니다. 대각선의 __proto__를 연결해나가기만 하면 무한대로 체인 관계를 이어나갈 수 있습니다. 이 방법으로부터 다른 언어의 클래스와 비슷하게 동작하는 구조를 만들 수 있는데, 이에 대해서는 7장에서 자세히 다루겠습니다. 

##### 대각선의 __proto__를 연결하는 방법은 __proto__가 가리키는 대상, 즉 생성자 함수의 prototype이 연결하고자 하는 상위 생성자 함수의 인스턴스를 바라보게끔 해주면 됩니다. 말로는 설명이 어려우니 예제를 통해 알아봅시다. 

<pre>
<code>
var Grade = function(){
    var args = Array.prototype.slice.call(arguments);
    for (var i = 0; i < args.length; i ++>){
        this[i] = args[i];
    }
    this.length = args.length;
};
var g = new Grade(100, 80);
</code>
</pre>

##### 변수 g는 Grade의 인스턴스를 바라봅니다. Grade의 인스턴스는 여러 개의 인자를 받아 각각 순서대로 인덱싱해서 저장하고 length 프로퍼티가 존재하는 등으로 배열의 형태를 지니지만, 배열의 메서드를 사용할 수는 없는 유사배열객체입니다. 일전에 유사배열객체에 배열 메서드를 적용하는 방법으로 call/apply를 소개했지만, 이번에는 기왕 생성자 함수를 직접 만든김에 인스턴스에서 배열 메서드를 직접 쓸 수 있게끔 하고 싶습니다. 그러기 위해서는 g.__proto__, 즉 Grade.prototype이 배열의 인스턴스를 바라보게 하면 됩니다. 

<pre>
<code>
Grade.prototype = [];
</code>
</pre>

##### 이 명령에 의해 그림 6-13과 같이 서로 별개로 분리돼 있던 데이터가 연결되어 그림 6-14와 같이 하나의 프로토타입 체인 형태를 띄게 됩니다. 이제는 Grade의 인스턴스인 g에서 직접 배열의 메서드를 사용할 수 있습니다. 

<pre>
<code>
console.log(g); //Grade(2) [100, 80]
g.pop();
console.log(g); //Grade(1) [100]
g.push(90);
console.log(g); //Grade(2) [100,90]
</code>
</pre>

##### g 인스턴스의 입장에서는 프로토타입 체인에 따라 g 객체 자신이 지니는 멤버, Grade의 prototype에 있는 멤버, Array.prototype에 있는 멤버, 끝으로 Object.prototype에 있는 멤버에 까지 접근할 수 있게 됐습니다. 

##### 이번 절은 '두 단계 이상의 체인을 지니는 다중 프로토타입 체인'도 가능하다는 사실을 확인한 정도로 만족하고, 본격적으로 이렇게 하는 이유, 구현 방식 및 문제 해결 등은 다음 장에서 더 자세히 살펴보겠습니다. 

