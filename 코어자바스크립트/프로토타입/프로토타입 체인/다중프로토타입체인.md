##### 자바스크립트의 기본 내장 데이터 타입들은 모두 프로토타입 체인이 1단계이거나 2단계로 끝나는 경우만 있었지만 사용자가 새롭게 만드는 경우에는 그 이상도 얼마든지 가능합니다. 대각선의 __proto__를 연결해나가기만 하면 무한대로 체인 관계를 이어나갈 수 있습니다. 이 방법으로부터 다른 언어의 클래스와 비슷하게 동작하는 구조를 만들 수 있는데, 이에 대해서는 7장에서 자세히 다루겠습니다. 

##### 대각선의 __proto__를 연결하는 방법은 __proto__가 가리키는 대상, 즉 생성자 함수의 prototype이 연결하고자 하는 상위 생성자 함수의 인스턴스를 바라보게끔 해주면 됩니다. 말로는 설명이 어려우니 예제를 통해 알아봅시다. 

<pre>
<code>
var Grade = function(){
    var args = Array.prototype.slice.call(arguments);
    for (var i = 0; i < args.length; i ++>){
        this[i] = args[i];
    }
    this.length = args.length;
};
var g = new Grade(100, 80);
</code>
</pre>

##### 변수 g는 Grade의 인스턴스를 바라봅니다. Grade의 인스턴스는 여러 개의 인자를 받아 각각 순서대로 인덱싱해서 저장하고 length 프로퍼티가 존재하는 등으로 배열의 형태를 지니지만, 배열의 메서드를 사용할 수는 없는 유사배열객체입니다. 일전에 유사배열객체에 배열 메서드를 적용하는 방법으로 call/apply를 소개했지만, 이번에는 기왕 생성자 함수를 직접 만든김에 인스턴스에서 배열 메서드를 직접 쓸 수 있게끔 하고 싶습니다. 그러기 위해서는 g.__proto__, 즉 Grade.prototype이 배열의 인스턴스를 바라보게 하면 됩니다. 

<pre>
<code>
Grade.prototype = [];
</code>
</pre>

##### 이 명령에 의해 그림 6-13과 같이 서로 별개로 분리돼 있던 데이터가 연결되어 그림 6-14와 같이 하나의 프로토타입 체인 형태를 띄게 됩니다. 이제는 Grade의 인스턴스인 g에서 직접 배열의 메서드를 사용할 수 있습니다. 

<pre>
<code>
console.log(g); //Grade(2) [100, 80]
g.pop();
console.log(g); //Grade(1) [100]
g.push(90);
console.log(g); //Grade(2) [100,90]
</code>
</pre>

##### g 인스턴스의 입장에서는 프로토타입 체인에 따라 g 객체 자신이 지니는 멤버, Grade의 prototype에 있는 멤버, Array.prototype에 있는 멤버, 끝으로 Object.prototype에 있는 멤버에 까지 접근할 수 있게 됐습니다. 

##### 이번 절은 '두 단계 이상의 체인을 지니는 다중 프로토타입 체인'도 가능하다는 사실을 확인한 정도로 만족하고, 본격적으로 이렇게 하는 이유, 구현 방식 및 문제 해결 등은 다음 장에서 더 자세히 살펴보겠습니다. 

##### 어떤 생성자 함수를 new 연산자와 함께 호출하면 constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성되는데, 이 인스턴스에는 __proto__라는, Constructor의 prototype프로퍼티를 참조하는 프로퍼티가 자동으로 부여됩니다. __proto__는 생략 가능한 속성이라서, 인스턴스는 Constructor.prototype의 메서드를 마치 자신의 메서드인 것처럼 호출할 수 있습니다. 

##### Constructor.prototype에는 constructor라는 프로퍼티가 있는데, 이는 다시 생성자 함수 자신을 가리킵니다. 이 프로퍼티는 인스턴스가 자신의 생성자 함수가 무엇인지 알고자 할 때 필요한 수단입니다. 직각삼각형의 대각선 방향, 즉 __proto__ 방향을 계속 찾아가면 최종적으로는 Object.prototype에 당도하게 됩니다. 이런 식으로 __proto__안에 다시 __proto__를 찾아가는 과정을 프로토타입 체이닝이라고 하며, 이 프로토타입 체이닝을 통해 각 프로토타입 메서드를 자신의 것처럼 호출할 수 있게 됩니다. 이떄 접근 방식은 자신으로부터 가장 가까운 대상부터 점차 먼 대상으로 나아가며, 원하는 값을 찾으면 검색을 중단합니다. 

##### Object.prototype에는 모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만이 존재하며, 객체 전용 메서드는 여느 데이터 타입과 달리 Object 생성자 함수에 스태틱하게 담겨있습니다. 

##### 프로토타입 체인은 반드시 2단계로만 이루어지는 것이 아니라 무한대의 단계를 생성할 수도 있습니다. 이에 대해서는 7장에서 자세히 다루어 보겟습니다. 

