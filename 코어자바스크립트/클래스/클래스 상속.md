##### 클래스 상속은 객체지향에서 가장 중요한 요소 중 하나입니다. 이 때문에 ES5까지의 자바스크립트 커뮤니티에서는 클래스 상속을 다른 객체지향 언어에 익숙한 개발자들에게 최대한 친숙한 형태로 흉내 내는 것이 주요한 관심사였습니다. 이번 절에서는 프로토타입 체인을 활용해 클래스 상속을 구현하고 최대한 전통적인 객체지향 언어에서의 클래스와 비슷한 형태로까지 발전시켜 보는 것을 목표로하겠습니다. 7-3절에서는 실제 적용을 위해 코드를 하나하나 분석하며 머리에 담고자 애쓰기 보다는 이해를 목표로 '예전에는 이런 다양한 방식으로 고군분투해왔구나'라는 마음으로 읽어보시기 바랍니다. 너무 무겁게 읽다가는 ES6 클래스 문법을 소개하는 7-4절에 이르렀을 떄 허무감을 느끼게 될 수도 있기 떄문입니다. 

##### 6-2-4절에서 다중 프로토타입 체인에 대해 살펴봤습니다. 사실 6-2-4절에서 다룬 내용이 클래스 상속의 핵심입니다. 예시를 다시 한 번 봅시다. 

<pre>
<code>
var Grade = function(){
    var args = Array.prototype.slice.call(arguments);
    for (var i = 0; i < args.length ; i ++){
        this[i] = args[i];
    }
    this.length = args.length;
};
Grade.prototype = [];
var g = new Grade(100, 80);
</code>
</pre>

##### 다시 한 번 강조하지만 ES5까지의 자바스크립트에는 클래스가 없습니다. ES6에서 클래스가 도입됐지만 역시나 prototype을 기반으로 한 것으로 기본적으로는 그림 7-6의 개념과 동일합니다. 그러니까 자바스크립트에서 클래스 상속을 구현했다는 것은 결국 프로토타입 체이닝을 잘 연결할 것으로 이해하면 되는 것입니다. 

##### 다만 '기본적으로는' 그렇다는 것이고, 세부적으로 완벽하게 superClass와 subClass의 구현이 이뤄진 것은 아닙니다. 예제 7-2에는 몇 가지 큰 문제가 있습니다. Length 프로퍼티가 configurable(삭제 가능) 하다는 점과, Grade.prototype에 빈 배열을 참조시켰다는 점이 그렇습니다. 

<pre>
<code>
...
g.push(90);
console.log(g); // Grade{ 0 : 100, 1: 80 , length: 3}

delete g.length;
g.push(70);
console.log(g); // Grade{ 0: 70, 1: 80, 2: 90, length: 1}
</code>
</pre>

##### 11번째 줄에서는 원하는 대로 결과가 잘 나왔습니다. 그런데 12번째 줄에서 length 프로퍼티를 삭제하고 다시 push를 했더니, push 한 값이 0번째 인덱스에 들어갔고, length가 1이 됐습니다. 내장객체인 배열 인스턴스의 length 프로퍼티는 configurable 속성이 false라서 삭제가 불가능하지만, Grade 클래스의 인스턴스는 배열 메서드를 상속하지만 기본적으로는 일반 객체의 성질을 그대로 지니므로 삭제가 가능해서 문제가 됩니다. 

##### 한편 push를 했을 때 0번째 인덱스에 70이 들어가고 length가 다시 1이 될 수 있었던 까닭은 무엇일까요? 바로 g.__proto__, 즉 Grade.prototype이 빈 배열을 가리키고 있기 때문입니다. push 명령에 의해 자바스크립트 엔진이 g.legnth를 읽고자 하는데 g.length가 없느이까 프로토타입 체이닝을 타고 g.__proto__.length를 읽어온 것이죠. 빈 배열의 length가 0이므로 여기에 값을 할당하고 legnth는 1만큼 증가시키라는 명령이 문제 없이 동작할 수 있었던 것입니다. 

##### 그럼 만약 Grade.prototype에 요소를 포함하는 배열을 매칭시켰다면 어땠을까요? 

<pre>
<code>
...
Grade.prototype = ['a', 'b', 'c', 'b'];
var g = new Grade(100, 80);

g.push(90);
console.log(g) // Grade {0 : 100, 1:80 , 2:90, ____ 4: 70, length: 5}
</code>
</pre>

##### 이번에는 prototype에 length가 4인 배열을 할당해봤습니다. 10, 11 번째 줄은 문제 없이 동작합니다. 그런데 12번째 줄에서 length를 삭제하고 나니 예제 7-3과는 다르게 동작하는 것을 확인할 수 있습니다. g.length가 없으니까 g.__proto__.length를 찾고, 값이 4이므로 인덱스 4에 70을 넣고, 다시 g.length 에 5를 부여하는 순서로 동작한 것이죠. 

##### 이처럼 클래스에 있는 값이 인스턴스의 동작에 영향을 줘서는 안 되겠습니다. 사실 이런 영향을 줄 수 있다는 사실 자체가 이미 클래스의 추상성을 해치는 것입니다. 인스턴스와의 관계에서는 구체적인 데이터를 지니지 않고 오직 인스턴스가 사용할 메서드만을 지니는 추상적인 '틀'로서만 작용하게끔 작성하지 ㅇ낳는다면 언젠가 어딘가에서 예제 7-3과 예제 7-4처럼 예기치 않은 오류가 발생할 가능성을 안고 가야 하는 것이죠. 

##### 클래스가 구체적인 데이터를 지니지 않기 위한 방법은 다음 절에서 다시 논하기로 하고, 우선은 다른 예제를 하나 더 살펴보겠습니다. 앞서는 Array 내장 클래스를 상속하는 Grade 클래스를 살펴봤는데, 이번에는 사용자가 정의한 두 클래스 사이에서의 상속관계를 구현해봅시다. 

##### 직사각형 클래스와 정사각형 클래스를 만들어볼가 합니다. 직사각형은 두 쌍의 마주 보는 변이 평행이고 그 길이가 같습니다. 정사각형은 직사각형이면서 네 변의 길이가 모두 같습니다. 각 클래스에는 넓이는 구하는 getArea 라는 메서드를 추가하겠습니다. 

<pre>
<code>
var Rectangle = function( width, height ){
    this.width = width;
    this.height = height; 
};

Rectangle.prototype.getArea = function() {
    return this.width * this.height; 
};
var rect = new Rectangle(3,4);
console.log(rect.getArea()); // 12

var Square = function(width){
    this.width = width;
}

Square.prototype.getArea = function(){
    return this.width * this.width;
}

var sq = new Square(5);
console.log(sq.getArea()) // 25

</code>
</pre>

##### 이렇게 작성하고 보니 Rectangle과 Square 클래스에 공통 요소가 보입니다. width 라는 프로퍼티가 공통이고, getArea는 내용이 다르지만 비슷합니다. 만약 Square에서 width 프로퍼티만 쓰지 않고 height 프로퍼티에 width 값을 부여하는 형태가 된다면 getArea도 동일하게 고칠 수 있겠습니다. 

<pre>
<code>
...
var Square = fucntioin(width){
    this.width = width;
    this.height = width; 
}

Square.prototype.getArea = function(){
    return this.width * this.height;
}
</code>
</pre>

##### 원래부터 정사각형은 직사각형에 '네 변의 길이가 모두 같다'라는 구체적인 조건이 하나 추가된 개념이죠. 예제 7-6처럼 고치고 나니 이제 소스상으로도 Square를 Rectangle의 하위 클래스로 삼을 수 잇을 것 같습니다. getArea라는 메서드는 동일한 동작을 하므로 상위 클래스에서만 정의하고, 하위 클래스에서는 해당 메서드를 상속하면서 height 대신 width를 넣어주면 되겠네요. 

<pre>
<code>
... 
var Square = fucntion(width){
    Rectangle.call(this, width, width);
};
Square.prototype = new Rectangle();
...
</code>
</pre>

##### 11번째 줄에서는 Square의 생성자 함수 내부에서 Rectangle의 생성자 함수를 함수로써 호출했습니다. 이때 인자 height 자리에 width를 전달했습니다. 13번째 줄에서는 메서드를 상속하기 위해 Square의 프로토타입 객체에 Rectangle의 인스턴스를 부여했습니다. 이것만으로도 일단은 원하는대로 동작합니다. 

##### 그러나 위 코드만으로 완벽한 클래스 체계가 구축됐다고 볼 수는 없습니다. 우선 예제 7-4와 동일한 방법으로 구현한 것이니 클래스에 있는 값이 인스턴스에 영향을 줄 수 있는 구조라는 동일한 문제를 가지고 있을 것입니다. 